<!DOCTYPE html>
<html>
  <head>
    <title>Stat 585 - Functions</title>
    <meta charset="utf-8">
    <meta name="author" content="Heike Hofmann and Susan VanderPlas" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="tweaks.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Stat 585 - Functions
### Heike Hofmann and Susan VanderPlas

---




## Functions in R

- We use functions all the time

- What if there isn't a built-in or package function?

- Idea: avoid repetitive coding (errors, hard to maintain)

- Instead:

--

  - Extract common operations
  
--

  - Wrap in a function
  
--

  - Reuse
  
---

## Basic Structure

- Name

- Input arguments
  - names
  - default value

- Body

- Output values

---

## A first function


```r
mymean &lt;- function(x) {
  avg &lt;- sum(x)/length(x) # body

  return(avg) # return value - alternatively we could just write `avg`
}

mymean(1:15)
```

```
## [1] 8
```

```r
mymean(c(1:15, NA))
```

```
## [1] NA
```

we want to deal with missing values more gracefully
---

## A first function - take 2

Parameters can have default values. 
Those values are included in the function specification


```r
mymean &lt;- function(x, na.rm = F) {
  # If na.rm is T, delete the missing value from x
  
  return(sum(x)/length(x))
}


mymean(1:15)
```

```
## [1] 8
```

```r
mymean(c(1:15, NA), na.rm=TRUE) # still doesn't do what we want
```

```
## [1] NA
```


---

## Conditionals


```r
if (condition) { # only one set of commands  
  statement      # is executed depending on 
} else {         # whether condition is true
  statement      # or false
}
```

- Condition is a logical **value** (`TRUE` or `FALSE`), i.e. has to be of length 1

- Use `&amp;` and `|` to combine several conditions

- `!` negates a condition (`!FALSE` is `TRUE`)

---

## Conditionals - if()

![If statement block diagram](if.svg)

---

## Conditionals - ifelse 
![If-else statement block diagram](ifelse.svg)

---

## A first function - take 3


```r
mymean &lt;- function(x, na.rm = F) {
  if (na.rm == TRUE) {
    x &lt;- na.omit(x)
  }
  
  return(sum(x)/length(x))
}

mymean(1:15)
```

```
## [1] 8
```

```r
mymean(c(1:15, NA), na.rm = F)
```

```
## [1] NA
```

```r
mymean(c(1:15, NA), na.rm = T)
```

```
## [1] 8
```

---

## Function `mymean`

|     |     |
| --- | --- |
| Name | `mymean` |
| Input arguments | `x, na.rm = T` |
|                 | names of parameters, default values | 
| Body | `if (na.rm) x &lt;- na.omit(x)` | 
| | `avg &lt;- sum(x)/length(x)` |
| Output | `return(avg)` |

---

## Function Writing

- Start simple, then extend

- Test out each step

- Don't try too much at once


---
class: inverse
## Your turn

- Write a function `sd` that computes the standard deviation of `x` "from scratch". Include a parameter `na.rm` in it

- `\(L(\lambda; x) = -n\lambda + log(\lambda) \cdot\sum x_i\)` is the log likelihood function of a Poisson variable x with parameter `\(\lambda &gt; 0\)`
  - Write a function `loglikpois` with parameters `lambda` and `x` (a vector) that computes the log likelihood value for lambda given observations `x`.
  - Make sure to check that `lambda` is positive; return an error message (using `stop()`) if it is not.
  - Plot the likelihood values for lambda between 0 and 10 for `x = c(1, 3, 2, 3, 0, 1, 0, 1, 3, 3)`
  
---

## Good Practice

- Use tabs to structure blocks of statements

- Build complex blocks of codes step by step
    - A function should complete one task
    - Chain multiple functions together with a meta-function for more complex tasks

- `# write comments!`


---

## Testing

- Always test your functions!
    - Check input types - #1 source of issues

- Even better: Have someone else test them for you

---

## When Things Go Wrong...

Debugging is an art, not a science

- By yourself
  - check your code step by step
  - explain your code to an inanimate object    
  .small[(traditionally, a rubber duck)]
  - include print statements to check intermediate results and assumptions
  - use `browser()`
  - investigate all warnings
  
- Ask a friend to look over your code &lt;div style='position:relative; padding-bottom:calc(51.54% + 44px)'&gt;&lt;iframe src='https://gfycat.com/ifr/ShockedSmoggyAnkole' frameborder='0' scrolling='no' width='50%' height='50%' style='position:absolute;top:0;left:0;' allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;

---

## First go to when you get an unexpected result

Placing output such as

- `cat()`
- `str()`
- `head()`
- `summary()`
- `print()`

in strategic places in functions,
are simple ways to build code up step-wise ensuring that each piece works (and figuring out where it fails)

---

## Example: Read code

What does this function do? How does it work?


```r
somefunction &lt;- function (...) 
{
    k &lt;- length(ll &lt;- list(...))
    if (k == 0L) 
        return(invisible())
    mc &lt;- match.call()
    for (i in 1L:k) if (!(is.logical(r &lt;- ll[[i]]) &amp;&amp; !any(is.na(r)) &amp;&amp; 
        all(r))) {
        ch &lt;- deparse(mc[[i + 1]], width.cutoff = 60L)
        if (length(ch) &gt; 1L) 
            ch &lt;- paste(ch[1L], "....")
        stop(paste(ch, " is not ", if (length(r) &gt; 1L) 
            "all ", "TRUE", sep = ""), call. = FALSE)
    }
    invisible()
}
```

&lt;!-- precursor of the stopifnot function --&gt;

---

## Step-by-step code checking

The `browser()` function allows stepping through your code.


```r
help(browser)
```

- `n`= executes the next line of code

- `c`= continue execution until the end of the function, and exit

- `where` gives you the stack information, the trace of the active function calls

- `Q` exits browser()

---

## Let's try browser()

`somefunction2()` function has `browser()` in first line of function


```r
somefunction2 &lt;- function (...) 
{
    browser()
    k &lt;- length(ll &lt;- list(...))
    if (k == 0L) 
        return(invisible())
    mc &lt;- match.call()
    for (i in 1L:k) if (!(is.logical(r &lt;- ll[[i]]) &amp;&amp; !any(is.na(r)) &amp;&amp; 
        all(r))) {
        ch &lt;- deparse(mc[[i + 1]], width.cutoff = 60L)
        if (length(ch) &gt; 1L) 
            ch &lt;- paste(ch[1L], "....")
        stop(paste(ch, " is not ", if (length(r) &gt; 1L) 
            "all ", "TRUE", sep = ""), call. = FALSE)
    }
    invisible()
}
```

---


```r
x &lt;- 1
somefunction2(x==x, 1+1==2, c(7+5==11.99999, 1+1==2))
```

Browser enables:

- printing of result of each line

- checking changes to values

- make sure that it results in what is expected

---

## `debug()`

- `debug(f)` &lt;br&gt;
automatically places a `browser()` statement in the first line of function `f`, i.e. browser starts every time the function `f` is being executed

- `undebug(f)` &lt;br&gt;
removes it.

-  `debugonce(f)` &lt;br&gt;
Convenient alternative: starts the browser the next time function `f` is being executed


---

## Setting error handling


- `options(error=recover)` will drop user into `browser()` upon an error

- `options(error=NULL)` default, do nothing

- `options(warn=2)` sets maximum number of warnings to be 2

- `options(warn=0)` warnings are stored until top level function finishes (default)

- `options(warn=-1)` ignore all warnings

---

## Traceback

`traceback()` shows the stack at the time the last error occurred

```r
f &lt;- function(x) { 
  w(x)
	g(h(x)) 
	w(x)
} 
g &lt;- function(x) {
	a &lt;- 10
	x
} 

h &lt;- function(x) {
	w(x) 
	w(x) 
}
	 
w &lt;- function(x) { 
	if (sample(10, 1) == 1) stop("This is an error!")
}

f() 
traceback()
```

---

## Traceback

  
```
&gt; f()
Error in w(x) : This is an error! 
&gt; traceback()
5: stop("This is an error!") at #2
4: w(x) at #2
3: h(x) at #3
2: g(h(x)) at #3
1: f()
```
---
class: inverse
## Your Turn: fix this!! (8 mins)

`larger(x,y)` is supposed to return the element-wise maximum of two vectors


```r
larger &lt;- function(x, y) { 
  y.is.bigger &lt;- y &gt; x 
	x[y.is.bigger] &lt;- y[y.is.bigger] 
	x
} 
larger(c(1, 5, 10), c(2, 4, 11)) 
```

```
## [1]  2  5 11
```

```r
larger(c(1, 5, 10), 6)
```

```
## [1]  6 NA 10
```
why is there an `NA` in the second example? It should be a 6. Figure out why this happens, and try to fix it.

---

## Iterations

- Run the same block of code multiple times:

```r
for (i in players) {
  #####################
  # Block of commands #
  #####################
  
  # Output
}
```

---

## Iterations

- Run the same block of code multiple times:

```r
for (i in players) {
  #####################
  # Block of commands #
  #####################
  
  print(avg)
}
```


---

## Iterations

- Run the same block of code multiple times:

```r
for (i in players) {
  
  player &lt;- subset(baseball, playerID == i)
  avg &lt;- sum(H/AB, na.rm = T)
  
  print(avg)
}
```

--

This is a loop, or iteration

---

## Iterations and R

- R is vector-based - many tasks don't require loops at all

- `for` loops are useful for debugging purposes

There are several alternatives to `for` loops in R. We will look into some alternatives next time:

- The `apply` series of functions (`lapply`, `sapply`, `mapply`, `tapply`) can be used to "loop" in R without an explicit for loop

- `purrr` is a tidyverse package used for functional programming
    - tidy version of `apply`: `map`
    - more consistent API


---
class: inverse
## Your Turn

[FizzBuzz](http://www.dr-mikes-math-games-for-kids.com/fizz-buzz.html) is a common game to teach children multiplication tables

Write a function that, for any number between lower bound `\(a\)` and upper bound `\(b\)`, outputs the correct response to FizzBuzz:

- if the number is divisible by 3, the program returns "fizz" instead of the number
- if the number is divisible by 7, the program returns "buzz" instead of the number
- if the number is divisible by 3 and 7, the program returns "fizzbuzz" instead of the number
- in any other case return the number unchanged

The modulus operator, `%%` will be useful.

1. Write a fizzbuzz function using a `for` loop

2. Can you make your function work without using a loop?

---
class: middle, center

no peeking before trying!

---

it's usually a good idea to break down tasks into very simple steps


```r
fizzbuzz1 &lt;- function(x) {
  # we assume x is a single number
  div3 &lt;- (x %% 3) == 0
  div7 &lt;- (x %% 7) == 0
  
  if (div3 &amp; div7) return("fizzbuzz")
  if (div3) return("fizz")
  if (div7) return("buzz")
  return(x)
}

fizzbuzz1(5)
```

```
## [1] 5
```

```r
fizzbuzz1(21)
```

```
## [1] "fizzbuzz"
```

---

Now wrap `fizzbuzz1` into a bigger function


```r
fizzbuzz &lt;- function(a, b) {
  # we assume a and b are integer values
  
  for (i in a:b) fizzbuzz1(i)
}

fizzbuzz(1,10)
```

Why isn't anything happening?

---

We need to make some space to save values


```r
fizzbuzz &lt;- function(a, b) {
  # we assume a and b are integer values
  
  idx &lt;- a:b
  result &lt;- rep(NA, length(idx))
  for (i in 1:length(idx)) 
    result[i] &lt;- fizzbuzz1(idx[i])
  
  result
}

fizzbuzz(1,10)
```

```
##  [1] "1"    "2"    "fizz" "4"    "5"    "fizz" "buzz" "8"    "fizz" "10"
```
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
